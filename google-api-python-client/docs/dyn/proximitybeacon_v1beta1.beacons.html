<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="proximitybeacon_v1beta1.html">Google Proximity Beacon API</a> . <a href="proximitybeacon_v1beta1.beacons.html">beacons</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="proximitybeacon_v1beta1.beacons.attachments.html">attachments()</a></code>
</p>
<p class="firstline">Returns the attachments Resource.</p>

<p class="toc_element">
  <code><a href="proximitybeacon_v1beta1.beacons.diagnostics.html">diagnostics()</a></code>
</p>
<p class="firstline">Returns the diagnostics Resource.</p>

<p class="toc_element">
  <code><a href="#activate">activate(beaconName, x__xgafv=None)</a></code></p>
<p class="firstline">(Re)activates a beacon. A beacon that is active will return information and attachment data when queried via `beaconinfo.getforobserved`. Calling this method on an already active beacon will do nothing (but will return a successful response code).</p>
<p class="toc_element">
  <code><a href="#deactivate">deactivate(beaconName, x__xgafv=None)</a></code></p>
<p class="firstline">Deactivates a beacon. Once deactivated, the API will not return information nor attachment data for the beacon when queried via `beaconinfo.getforobserved`. Calling this method on an already inactive beacon will do nothing (but will return a successful response code).</p>
<p class="toc_element">
  <code><a href="#decommission">decommission(beaconName, x__xgafv=None)</a></code></p>
<p class="firstline">Decommissions the specified beacon in the service. This beacon will no longer be returned from `beaconinfo.getforobserved`. This operation is permanent -- you will not be able to re-register a beacon with this ID again.</p>
<p class="toc_element">
  <code><a href="#get">get(beaconName, x__xgafv=None)</a></code></p>
<p class="firstline">Returns detailed information about the specified beacon.</p>
<p class="toc_element">
  <code><a href="#list">list(pageSize=None, q=None, pageToken=None, x__xgafv=None)</a></code></p>
<p class="firstline">Searches the beacon registry for beacons that match the given search criteria. Only those beacons that the client has permission to list will be returned.</p>
<p class="toc_element">
  <code><a href="#list_next">list_next(previous_request, previous_response)</a></code></p>
<p class="firstline">Retrieves the next page of results.</p>
<p class="toc_element">
  <code><a href="#register">register(body, x__xgafv=None)</a></code></p>
<p class="firstline">Registers a previously unregistered beacon given its `advertisedId`. These IDs are unique within the system. An ID can be registered only once.</p>
<p class="toc_element">
  <code><a href="#update">update(beaconName, body, x__xgafv=None)</a></code></p>
<p class="firstline">Updates the information about the specified beacon. **Any field that you do not populate in the submitted beacon will be permanently erased**, so you should follow the "read, modify, write" pattern to avoid inadvertently destroying data. Changes to the beacon status via this method will be silently ignored. To update beacon status, use the separate methods on this API for (de)activation and decommissioning.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="activate">activate(beaconName, x__xgafv=None)</code>
  <pre>(Re)activates a beacon. A beacon that is active will return information and attachment data when queried via `beaconinfo.getforobserved`. Calling this method on an already active beacon will do nothing (but will return a successful response code).

Args:
  beaconName: string, The beacon to activate. Required. (required)
  x__xgafv: string, V1 error format.

Returns:
  An object of the form:

    { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } The JSON representation for `Empty` is empty JSON object `{}`.
  }</pre>
</div>

<div class="method">
    <code class="details" id="deactivate">deactivate(beaconName, x__xgafv=None)</code>
  <pre>Deactivates a beacon. Once deactivated, the API will not return information nor attachment data for the beacon when queried via `beaconinfo.getforobserved`. Calling this method on an already inactive beacon will do nothing (but will return a successful response code).

Args:
  beaconName: string, The beacon name of this beacon. (required)
  x__xgafv: string, V1 error format.

Returns:
  An object of the form:

    { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } The JSON representation for `Empty` is empty JSON object `{}`.
  }</pre>
</div>

<div class="method">
    <code class="details" id="decommission">decommission(beaconName, x__xgafv=None)</code>
  <pre>Decommissions the specified beacon in the service. This beacon will no longer be returned from `beaconinfo.getforobserved`. This operation is permanent -- you will not be able to re-register a beacon with this ID again.

Args:
  beaconName: string, Beacon that should be decommissioned. Required. (required)
  x__xgafv: string, V1 error format.

Returns:
  An object of the form:

    { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } The JSON representation for `Empty` is empty JSON object `{}`.
  }</pre>
</div>

<div class="method">
    <code class="details" id="get">get(beaconName, x__xgafv=None)</code>
  <pre>Returns detailed information about the specified beacon.

Args:
  beaconName: string, Beacon that is requested. (required)
  x__xgafv: string, V1 error format.

Returns:
  An object of the form:

    { # Details of a beacon device.
    "status": "A String", # Current status of the beacon. Required.
    "description": "A String", # Free text used to identify and describe the beacon. Maximum length 140 characters. Optional.
    "indoorLevel": { # Indoor level, a human-readable string as returned by Google Maps APIs, useful to indicate which floor of a building a beacon is located on. # The indoor level information for this beacon, if known. As returned by the Google Maps API. Optional.
      "name": "A String", # The name of this level.
    },
    "latLng": { # An object representing a latitude/longitude pair. This is expressed as a pair of doubles representing degrees latitude and degrees longitude. Unless specified otherwise, this must conform to the WGS84 standard. Values must be within normalized ranges. Example of normalization code in Python: def NormalizeLongitude(longitude): """Wrapsdecimal degrees longitude to [-180.0, 180.0].""" q, r = divmod(longitude, 360.0) if r > 180.0 or (r == 180.0 and q <= -1.0): return r - 360.0 return r def NormalizeLatLng(latitude, longitude): """Wraps decimal degrees latitude and longitude to [-180.0, 180.0] and [-90.0, 90.0], respectively.""" r = latitude % 360.0 if r = 270.0: return r - 360, NormalizeLongitude(longitude) else: return 180 - r, NormalizeLongitude(longitude + 180.0) assert 180.0 == NormalizeLongitude(180.0) assert -180.0 == NormalizeLongitude(-180.0) assert -179.0 == NormalizeLongitude(181.0) assert (0.0, 0.0) == NormalizeLatLng(360.0, 0.0) assert (0.0, 0.0) == NormalizeLatLng(-360.0, 0.0) assert (85.0, 180.0) == NormalizeLatLng(95.0, 0.0) assert (-85.0, -170.0) == NormalizeLatLng(-95.0, 10.0) assert (90.0, 10.0) == NormalizeLatLng(90.0, 10.0) assert (-90.0, -10.0) == NormalizeLatLng(-90.0, -10.0) assert (0.0, -170.0) == NormalizeLatLng(-180.0, 10.0) assert (0.0, -170.0) == NormalizeLatLng(180.0, 10.0) assert (-90.0, 10.0) == NormalizeLatLng(270.0, 10.0) assert (90.0, 10.0) == NormalizeLatLng(-270.0, 10.0) # The location of the beacon, expressed as a latitude and longitude pair. This location is given when the beacon is registered or updated. It does not necessarily indicate the actual current location of the beacon. Optional.
      "latitude": 3.14, # The latitude in degrees. It must be in the range [-90.0, +90.0].
      "longitude": 3.14, # The longitude in degrees. It must be in the range [-180.0, +180.0].
    },
    "placeId": "A String", # The [Google Places API](/places/place-id) Place ID of the place where the beacon is deployed. This is given when the beacon is registered or updated, not automatically detected in any way. Optional.
    "advertisedId": { # Defines a unique identifier of a beacon as broadcast by the device. # The identifier of a beacon as advertised by it. This field must be populated when registering. It may be empty when updating a beacon record because it is ignored in updates.
      "type": "A String", # Specifies the identifier type. Required.
      "id": "A String", # The actual beacon identifier, as broadcast by the beacon hardware. Must be [base64](http://tools.ietf.org/html/rfc4648#section-4) encoded in HTTP requests, and will be so encoded (with padding) in responses. The base64 encoding should be of the binary byte-stream and not any textual (such as hex) representation thereof. Required.
    },
    "beaconName": "A String", # Resource name of this beacon. A beacon name has the format "beacons/N!beaconId" where the beaconId is the base16 ID broadcast by the beacon and N is a code for the beacon's type. Possible values are `3` for Eddystone, `1` for iBeacon, or `5` for AltBeacon. This field must be left empty when registering. After reading a beacon, clients can use the name for future operations.
    "expectedStability": "A String", # Expected location stability. This is set when the beacon is registered or updated, not automatically detected in any way. Optional.
    "properties": { # Properties of the beacon device, for example battery type or firmware version. Optional.
      "a_key": "A String",
    },
  }</pre>
</div>

<div class="method">
    <code class="details" id="list">list(pageSize=None, q=None, pageToken=None, x__xgafv=None)</code>
  <pre>Searches the beacon registry for beacons that match the given search criteria. Only those beacons that the client has permission to list will be returned.

Args:
  pageSize: integer, The maximum number of records to return for this request, up to a server-defined upper limit.
  q: string, Filter query string that supports the following field filters: * `description:""` For example: `description:"Room 3"` Returns beacons whose description matches tokens in the string "Room 3" (not necessarily that exact string). The string must be double-quoted. * `status:` For example: `status:active` Returns beacons whose status matches the given value. Values must be one of the Beacon.Status enum values (case insensitive). Accepts multiple filters which will be combined with OR logic. * `stability:` For example: `stability:mobile` Returns beacons whose expected stability matches the given value. Values must be one of the Beacon.Stability enum values (case insensitive). Accepts multiple filters which will be combined with OR logic. * `place_id:""` For example: `place_id:"ChIJVSZzVR8FdkgRXGmmm6SslKw="` Returns beacons explicitly registered at the given place, expressed as a Place ID obtained from [Google Places API](/places/place-id). Does not match places inside the given place. Does not consider the beacon's actual location (which may be different from its registered place). Accepts multiple filters that will be combined with OR logic. The place ID must be double-quoted. * `registration_time[|=]` For example: `registration_time>=1433116800` Returns beacons whose registration time matches the given filter. Supports the operators: , =. Timestamp must be expressed as an integer number of seconds since midnight January 1, 1970 UTC. Accepts at most two filters that will be combined with AND logic, to support "between" semantics. If more than two are supplied, the latter ones are ignored. * `lat: lng: radius:` For example: `lat:51.1232343 lng:-1.093852 radius:1000` Returns beacons whose registered location is within the given circle. When any of these fields are given, all are required. Latitude and longitude must be decimal degrees between -90.0 and 90.0 and between -180.0 and 180.0 respectively. Radius must be an integer number of meters less than 1,000,000 (1000 km). * `property:"="` For example: `property:"battery-type=CR2032"` Returns beacons which have a property of the given name and value. Supports multiple filters which will be combined with OR logic. The entire name=value string must be double-quoted as one string. * `attachment_type:""` For example: `attachment_type:"my-namespace/my-type"` Returns beacons having at least one attachment of the given namespaced type. Supports "any within this namespace" via the partial wildcard syntax: "my-namespace/*". Supports multiple filters which will be combined with OR logic. The string must be double-quoted. Multiple filters on the same field are combined with OR logic (except registration_time which is combined with AND logic). Multiple filters on different fields are combined with AND logic. Filters should be separated by spaces. As with any HTTP query string parameter, the whole filter expression must be URL-encoded. Example REST request: `GET /v1beta1/beacons?q=status:active%20lat:51.123%20lng:-1.095%20radius:1000`
  pageToken: string, A pagination token obtained from a previous request to list beacons.
  x__xgafv: string, V1 error format.

Returns:
  An object of the form:

    { # Response that contains list beacon results and pagination help.
    "beacons": [ # The beacons that matched the search criteria.
      { # Details of a beacon device.
        "status": "A String", # Current status of the beacon. Required.
        "description": "A String", # Free text used to identify and describe the beacon. Maximum length 140 characters. Optional.
        "indoorLevel": { # Indoor level, a human-readable string as returned by Google Maps APIs, useful to indicate which floor of a building a beacon is located on. # The indoor level information for this beacon, if known. As returned by the Google Maps API. Optional.
          "name": "A String", # The name of this level.
        },
        "latLng": { # An object representing a latitude/longitude pair. This is expressed as a pair of doubles representing degrees latitude and degrees longitude. Unless specified otherwise, this must conform to the WGS84 standard. Values must be within normalized ranges. Example of normalization code in Python: def NormalizeLongitude(longitude): """Wrapsdecimal degrees longitude to [-180.0, 180.0].""" q, r = divmod(longitude, 360.0) if r > 180.0 or (r == 180.0 and q <= -1.0): return r - 360.0 return r def NormalizeLatLng(latitude, longitude): """Wraps decimal degrees latitude and longitude to [-180.0, 180.0] and [-90.0, 90.0], respectively.""" r = latitude % 360.0 if r = 270.0: return r - 360, NormalizeLongitude(longitude) else: return 180 - r, NormalizeLongitude(longitude + 180.0) assert 180.0 == NormalizeLongitude(180.0) assert -180.0 == NormalizeLongitude(-180.0) assert -179.0 == NormalizeLongitude(181.0) assert (0.0, 0.0) == NormalizeLatLng(360.0, 0.0) assert (0.0, 0.0) == NormalizeLatLng(-360.0, 0.0) assert (85.0, 180.0) == NormalizeLatLng(95.0, 0.0) assert (-85.0, -170.0) == NormalizeLatLng(-95.0, 10.0) assert (90.0, 10.0) == NormalizeLatLng(90.0, 10.0) assert (-90.0, -10.0) == NormalizeLatLng(-90.0, -10.0) assert (0.0, -170.0) == NormalizeLatLng(-180.0, 10.0) assert (0.0, -170.0) == NormalizeLatLng(180.0, 10.0) assert (-90.0, 10.0) == NormalizeLatLng(270.0, 10.0) assert (90.0, 10.0) == NormalizeLatLng(-270.0, 10.0) # The location of the beacon, expressed as a latitude and longitude pair. This location is given when the beacon is registered or updated. It does not necessarily indicate the actual current location of the beacon. Optional.
          "latitude": 3.14, # The latitude in degrees. It must be in the range [-90.0, +90.0].
          "longitude": 3.14, # The longitude in degrees. It must be in the range [-180.0, +180.0].
        },
        "placeId": "A String", # The [Google Places API](/places/place-id) Place ID of the place where the beacon is deployed. This is given when the beacon is registered or updated, not automatically detected in any way. Optional.
        "advertisedId": { # Defines a unique identifier of a beacon as broadcast by the device. # The identifier of a beacon as advertised by it. This field must be populated when registering. It may be empty when updating a beacon record because it is ignored in updates.
          "type": "A String", # Specifies the identifier type. Required.
          "id": "A String", # The actual beacon identifier, as broadcast by the beacon hardware. Must be [base64](http://tools.ietf.org/html/rfc4648#section-4) encoded in HTTP requests, and will be so encoded (with padding) in responses. The base64 encoding should be of the binary byte-stream and not any textual (such as hex) representation thereof. Required.
        },
        "beaconName": "A String", # Resource name of this beacon. A beacon name has the format "beacons/N!beaconId" where the beaconId is the base16 ID broadcast by the beacon and N is a code for the beacon's type. Possible values are `3` for Eddystone, `1` for iBeacon, or `5` for AltBeacon. This field must be left empty when registering. After reading a beacon, clients can use the name for future operations.
        "expectedStability": "A String", # Expected location stability. This is set when the beacon is registered or updated, not automatically detected in any way. Optional.
        "properties": { # Properties of the beacon device, for example battery type or firmware version. Optional.
          "a_key": "A String",
        },
      },
    ],
    "nextPageToken": "A String", # An opaque pagination token that the client may provide in their next request to retrieve the next page of results.
    "totalCount": "A String", # Estimate of the total number of beacons matched by the query. Higher values may be less accurate.
  }</pre>
</div>

<div class="method">
    <code class="details" id="list_next">list_next(previous_request, previous_response)</code>
  <pre>Retrieves the next page of results.

Args:
  previous_request: The request for the previous page. (required)
  previous_response: The response from the request for the previous page. (required)

Returns:
  A request object that you can call 'execute()' on to request the next
  page. Returns None if there are no more items in the collection.
    </pre>
</div>

<div class="method">
    <code class="details" id="register">register(body, x__xgafv=None)</code>
  <pre>Registers a previously unregistered beacon given its `advertisedId`. These IDs are unique within the system. An ID can be registered only once.

Args:
  body: object, The request body. (required)
    The object takes the form of:

{ # Details of a beacon device.
  "status": "A String", # Current status of the beacon. Required.
  "description": "A String", # Free text used to identify and describe the beacon. Maximum length 140 characters. Optional.
  "indoorLevel": { # Indoor level, a human-readable string as returned by Google Maps APIs, useful to indicate which floor of a building a beacon is located on. # The indoor level information for this beacon, if known. As returned by the Google Maps API. Optional.
    "name": "A String", # The name of this level.
  },
  "latLng": { # An object representing a latitude/longitude pair. This is expressed as a pair of doubles representing degrees latitude and degrees longitude. Unless specified otherwise, this must conform to the WGS84 standard. Values must be within normalized ranges. Example of normalization code in Python: def NormalizeLongitude(longitude): """Wrapsdecimal degrees longitude to [-180.0, 180.0].""" q, r = divmod(longitude, 360.0) if r > 180.0 or (r == 180.0 and q <= -1.0): return r - 360.0 return r def NormalizeLatLng(latitude, longitude): """Wraps decimal degrees latitude and longitude to [-180.0, 180.0] and [-90.0, 90.0], respectively.""" r = latitude % 360.0 if r = 270.0: return r - 360, NormalizeLongitude(longitude) else: return 180 - r, NormalizeLongitude(longitude + 180.0) assert 180.0 == NormalizeLongitude(180.0) assert -180.0 == NormalizeLongitude(-180.0) assert -179.0 == NormalizeLongitude(181.0) assert (0.0, 0.0) == NormalizeLatLng(360.0, 0.0) assert (0.0, 0.0) == NormalizeLatLng(-360.0, 0.0) assert (85.0, 180.0) == NormalizeLatLng(95.0, 0.0) assert (-85.0, -170.0) == NormalizeLatLng(-95.0, 10.0) assert (90.0, 10.0) == NormalizeLatLng(90.0, 10.0) assert (-90.0, -10.0) == NormalizeLatLng(-90.0, -10.0) assert (0.0, -170.0) == NormalizeLatLng(-180.0, 10.0) assert (0.0, -170.0) == NormalizeLatLng(180.0, 10.0) assert (-90.0, 10.0) == NormalizeLatLng(270.0, 10.0) assert (90.0, 10.0) == NormalizeLatLng(-270.0, 10.0) # The location of the beacon, expressed as a latitude and longitude pair. This location is given when the beacon is registered or updated. It does not necessarily indicate the actual current location of the beacon. Optional.
    "latitude": 3.14, # The latitude in degrees. It must be in the range [-90.0, +90.0].
    "longitude": 3.14, # The longitude in degrees. It must be in the range [-180.0, +180.0].
  },
  "placeId": "A String", # The [Google Places API](/places/place-id) Place ID of the place where the beacon is deployed. This is given when the beacon is registered or updated, not automatically detected in any way. Optional.
  "advertisedId": { # Defines a unique identifier of a beacon as broadcast by the device. # The identifier of a beacon as advertised by it. This field must be populated when registering. It may be empty when updating a beacon record because it is ignored in updates.
    "type": "A String", # Specifies the identifier type. Required.
    "id": "A String", # The actual beacon identifier, as broadcast by the beacon hardware. Must be [base64](http://tools.ietf.org/html/rfc4648#section-4) encoded in HTTP requests, and will be so encoded (with padding) in responses. The base64 encoding should be of the binary byte-stream and not any textual (such as hex) representation thereof. Required.
  },
  "beaconName": "A String", # Resource name of this beacon. A beacon name has the format "beacons/N!beaconId" where the beaconId is the base16 ID broadcast by the beacon and N is a code for the beacon's type. Possible values are `3` for Eddystone, `1` for iBeacon, or `5` for AltBeacon. This field must be left empty when registering. After reading a beacon, clients can use the name for future operations.
  "expectedStability": "A String", # Expected location stability. This is set when the beacon is registered or updated, not automatically detected in any way. Optional.
  "properties": { # Properties of the beacon device, for example battery type or firmware version. Optional.
    "a_key": "A String",
  },
}

  x__xgafv: string, V1 error format.

Returns:
  An object of the form:

    { # Details of a beacon device.
    "status": "A String", # Current status of the beacon. Required.
    "description": "A String", # Free text used to identify and describe the beacon. Maximum length 140 characters. Optional.
    "indoorLevel": { # Indoor level, a human-readable string as returned by Google Maps APIs, useful to indicate which floor of a building a beacon is located on. # The indoor level information for this beacon, if known. As returned by the Google Maps API. Optional.
      "name": "A String", # The name of this level.
    },
    "latLng": { # An object representing a latitude/longitude pair. This is expressed as a pair of doubles representing degrees latitude and degrees longitude. Unless specified otherwise, this must conform to the WGS84 standard. Values must be within normalized ranges. Example of normalization code in Python: def NormalizeLongitude(longitude): """Wrapsdecimal degrees longitude to [-180.0, 180.0].""" q, r = divmod(longitude, 360.0) if r > 180.0 or (r == 180.0 and q <= -1.0): return r - 360.0 return r def NormalizeLatLng(latitude, longitude): """Wraps decimal degrees latitude and longitude to [-180.0, 180.0] and [-90.0, 90.0], respectively.""" r = latitude % 360.0 if r = 270.0: return r - 360, NormalizeLongitude(longitude) else: return 180 - r, NormalizeLongitude(longitude + 180.0) assert 180.0 == NormalizeLongitude(180.0) assert -180.0 == NormalizeLongitude(-180.0) assert -179.0 == NormalizeLongitude(181.0) assert (0.0, 0.0) == NormalizeLatLng(360.0, 0.0) assert (0.0, 0.0) == NormalizeLatLng(-360.0, 0.0) assert (85.0, 180.0) == NormalizeLatLng(95.0, 0.0) assert (-85.0, -170.0) == NormalizeLatLng(-95.0, 10.0) assert (90.0, 10.0) == NormalizeLatLng(90.0, 10.0) assert (-90.0, -10.0) == NormalizeLatLng(-90.0, -10.0) assert (0.0, -170.0) == NormalizeLatLng(-180.0, 10.0) assert (0.0, -170.0) == NormalizeLatLng(180.0, 10.0) assert (-90.0, 10.0) == NormalizeLatLng(270.0, 10.0) assert (90.0, 10.0) == NormalizeLatLng(-270.0, 10.0) # The location of the beacon, expressed as a latitude and longitude pair. This location is given when the beacon is registered or updated. It does not necessarily indicate the actual current location of the beacon. Optional.
      "latitude": 3.14, # The latitude in degrees. It must be in the range [-90.0, +90.0].
      "longitude": 3.14, # The longitude in degrees. It must be in the range [-180.0, +180.0].
    },
    "placeId": "A String", # The [Google Places API](/places/place-id) Place ID of the place where the beacon is deployed. This is given when the beacon is registered or updated, not automatically detected in any way. Optional.
    "advertisedId": { # Defines a unique identifier of a beacon as broadcast by the device. # The identifier of a beacon as advertised by it. This field must be populated when registering. It may be empty when updating a beacon record because it is ignored in updates.
      "type": "A String", # Specifies the identifier type. Required.
      "id": "A String", # The actual beacon identifier, as broadcast by the beacon hardware. Must be [base64](http://tools.ietf.org/html/rfc4648#section-4) encoded in HTTP requests, and will be so encoded (with padding) in responses. The base64 encoding should be of the binary byte-stream and not any textual (such as hex) representation thereof. Required.
    },
    "beaconName": "A String", # Resource name of this beacon. A beacon name has the format "beacons/N!beaconId" where the beaconId is the base16 ID broadcast by the beacon and N is a code for the beacon's type. Possible values are `3` for Eddystone, `1` for iBeacon, or `5` for AltBeacon. This field must be left empty when registering. After reading a beacon, clients can use the name for future operations.
    "expectedStability": "A String", # Expected location stability. This is set when the beacon is registered or updated, not automatically detected in any way. Optional.
    "properties": { # Properties of the beacon device, for example battery type or firmware version. Optional.
      "a_key": "A String",
    },
  }</pre>
</div>

<div class="method">
    <code class="details" id="update">update(beaconName, body, x__xgafv=None)</code>
  <pre>Updates the information about the specified beacon. **Any field that you do not populate in the submitted beacon will be permanently erased**, so you should follow the "read, modify, write" pattern to avoid inadvertently destroying data. Changes to the beacon status via this method will be silently ignored. To update beacon status, use the separate methods on this API for (de)activation and decommissioning.

Args:
  beaconName: string, Resource name of this beacon. A beacon name has the format "beacons/N!beaconId" where the beaconId is the base16 ID broadcast by the beacon and N is a code for the beacon's type. Possible values are `3` for Eddystone, `1` for iBeacon, or `5` for AltBeacon. This field must be left empty when registering. After reading a beacon, clients can use the name for future operations. (required)
  body: object, The request body. (required)
    The object takes the form of:

{ # Details of a beacon device.
  "status": "A String", # Current status of the beacon. Required.
  "description": "A String", # Free text used to identify and describe the beacon. Maximum length 140 characters. Optional.
  "indoorLevel": { # Indoor level, a human-readable string as returned by Google Maps APIs, useful to indicate which floor of a building a beacon is located on. # The indoor level information for this beacon, if known. As returned by the Google Maps API. Optional.
    "name": "A String", # The name of this level.
  },
  "latLng": { # An object representing a latitude/longitude pair. This is expressed as a pair of doubles representing degrees latitude and degrees longitude. Unless specified otherwise, this must conform to the WGS84 standard. Values must be within normalized ranges. Example of normalization code in Python: def NormalizeLongitude(longitude): """Wrapsdecimal degrees longitude to [-180.0, 180.0].""" q, r = divmod(longitude, 360.0) if r > 180.0 or (r == 180.0 and q <= -1.0): return r - 360.0 return r def NormalizeLatLng(latitude, longitude): """Wraps decimal degrees latitude and longitude to [-180.0, 180.0] and [-90.0, 90.0], respectively.""" r = latitude % 360.0 if r = 270.0: return r - 360, NormalizeLongitude(longitude) else: return 180 - r, NormalizeLongitude(longitude + 180.0) assert 180.0 == NormalizeLongitude(180.0) assert -180.0 == NormalizeLongitude(-180.0) assert -179.0 == NormalizeLongitude(181.0) assert (0.0, 0.0) == NormalizeLatLng(360.0, 0.0) assert (0.0, 0.0) == NormalizeLatLng(-360.0, 0.0) assert (85.0, 180.0) == NormalizeLatLng(95.0, 0.0) assert (-85.0, -170.0) == NormalizeLatLng(-95.0, 10.0) assert (90.0, 10.0) == NormalizeLatLng(90.0, 10.0) assert (-90.0, -10.0) == NormalizeLatLng(-90.0, -10.0) assert (0.0, -170.0) == NormalizeLatLng(-180.0, 10.0) assert (0.0, -170.0) == NormalizeLatLng(180.0, 10.0) assert (-90.0, 10.0) == NormalizeLatLng(270.0, 10.0) assert (90.0, 10.0) == NormalizeLatLng(-270.0, 10.0) # The location of the beacon, expressed as a latitude and longitude pair. This location is given when the beacon is registered or updated. It does not necessarily indicate the actual current location of the beacon. Optional.
    "latitude": 3.14, # The latitude in degrees. It must be in the range [-90.0, +90.0].
    "longitude": 3.14, # The longitude in degrees. It must be in the range [-180.0, +180.0].
  },
  "placeId": "A String", # The [Google Places API](/places/place-id) Place ID of the place where the beacon is deployed. This is given when the beacon is registered or updated, not automatically detected in any way. Optional.
  "advertisedId": { # Defines a unique identifier of a beacon as broadcast by the device. # The identifier of a beacon as advertised by it. This field must be populated when registering. It may be empty when updating a beacon record because it is ignored in updates.
    "type": "A String", # Specifies the identifier type. Required.
    "id": "A String", # The actual beacon identifier, as broadcast by the beacon hardware. Must be [base64](http://tools.ietf.org/html/rfc4648#section-4) encoded in HTTP requests, and will be so encoded (with padding) in responses. The base64 encoding should be of the binary byte-stream and not any textual (such as hex) representation thereof. Required.
  },
  "beaconName": "A String", # Resource name of this beacon. A beacon name has the format "beacons/N!beaconId" where the beaconId is the base16 ID broadcast by the beacon and N is a code for the beacon's type. Possible values are `3` for Eddystone, `1` for iBeacon, or `5` for AltBeacon. This field must be left empty when registering. After reading a beacon, clients can use the name for future operations.
  "expectedStability": "A String", # Expected location stability. This is set when the beacon is registered or updated, not automatically detected in any way. Optional.
  "properties": { # Properties of the beacon device, for example battery type or firmware version. Optional.
    "a_key": "A String",
  },
}

  x__xgafv: string, V1 error format.

Returns:
  An object of the form:

    { # Details of a beacon device.
    "status": "A String", # Current status of the beacon. Required.
    "description": "A String", # Free text used to identify and describe the beacon. Maximum length 140 characters. Optional.
    "indoorLevel": { # Indoor level, a human-readable string as returned by Google Maps APIs, useful to indicate which floor of a building a beacon is located on. # The indoor level information for this beacon, if known. As returned by the Google Maps API. Optional.
      "name": "A String", # The name of this level.
    },
    "latLng": { # An object representing a latitude/longitude pair. This is expressed as a pair of doubles representing degrees latitude and degrees longitude. Unless specified otherwise, this must conform to the WGS84 standard. Values must be within normalized ranges. Example of normalization code in Python: def NormalizeLongitude(longitude): """Wrapsdecimal degrees longitude to [-180.0, 180.0].""" q, r = divmod(longitude, 360.0) if r > 180.0 or (r == 180.0 and q <= -1.0): return r - 360.0 return r def NormalizeLatLng(latitude, longitude): """Wraps decimal degrees latitude and longitude to [-180.0, 180.0] and [-90.0, 90.0], respectively.""" r = latitude % 360.0 if r = 270.0: return r - 360, NormalizeLongitude(longitude) else: return 180 - r, NormalizeLongitude(longitude + 180.0) assert 180.0 == NormalizeLongitude(180.0) assert -180.0 == NormalizeLongitude(-180.0) assert -179.0 == NormalizeLongitude(181.0) assert (0.0, 0.0) == NormalizeLatLng(360.0, 0.0) assert (0.0, 0.0) == NormalizeLatLng(-360.0, 0.0) assert (85.0, 180.0) == NormalizeLatLng(95.0, 0.0) assert (-85.0, -170.0) == NormalizeLatLng(-95.0, 10.0) assert (90.0, 10.0) == NormalizeLatLng(90.0, 10.0) assert (-90.0, -10.0) == NormalizeLatLng(-90.0, -10.0) assert (0.0, -170.0) == NormalizeLatLng(-180.0, 10.0) assert (0.0, -170.0) == NormalizeLatLng(180.0, 10.0) assert (-90.0, 10.0) == NormalizeLatLng(270.0, 10.0) assert (90.0, 10.0) == NormalizeLatLng(-270.0, 10.0) # The location of the beacon, expressed as a latitude and longitude pair. This location is given when the beacon is registered or updated. It does not necessarily indicate the actual current location of the beacon. Optional.
      "latitude": 3.14, # The latitude in degrees. It must be in the range [-90.0, +90.0].
      "longitude": 3.14, # The longitude in degrees. It must be in the range [-180.0, +180.0].
    },
    "placeId": "A String", # The [Google Places API](/places/place-id) Place ID of the place where the beacon is deployed. This is given when the beacon is registered or updated, not automatically detected in any way. Optional.
    "advertisedId": { # Defines a unique identifier of a beacon as broadcast by the device. # The identifier of a beacon as advertised by it. This field must be populated when registering. It may be empty when updating a beacon record because it is ignored in updates.
      "type": "A String", # Specifies the identifier type. Required.
      "id": "A String", # The actual beacon identifier, as broadcast by the beacon hardware. Must be [base64](http://tools.ietf.org/html/rfc4648#section-4) encoded in HTTP requests, and will be so encoded (with padding) in responses. The base64 encoding should be of the binary byte-stream and not any textual (such as hex) representation thereof. Required.
    },
    "beaconName": "A String", # Resource name of this beacon. A beacon name has the format "beacons/N!beaconId" where the beaconId is the base16 ID broadcast by the beacon and N is a code for the beacon's type. Possible values are `3` for Eddystone, `1` for iBeacon, or `5` for AltBeacon. This field must be left empty when registering. After reading a beacon, clients can use the name for future operations.
    "expectedStability": "A String", # Expected location stability. This is set when the beacon is registered or updated, not automatically detected in any way. Optional.
    "properties": { # Properties of the beacon device, for example battery type or firmware version. Optional.
      "a_key": "A String",
    },
  }</pre>
</div>

</body></html>